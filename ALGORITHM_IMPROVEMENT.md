# 方向判斷演算法改進

## 問題回顧

### 原始問題
當前視窗在 **(991, 0)** - 螢幕右上角  
按「向下」快速鍵  
選到的視窗在 **(220, 88)** - 螢幕左邊

**不合理**：向下不應該選到左邊的視窗！

## 根本原因

原本的演算法只考慮**絕對方向**：
- 向下 = y 座標更大
- 向右 = x 座標更大

但沒有考慮**相對位置**的重要性。

### 舊演算法
```typescript
// 只看距離，不管方向偏離程度
distance = √[(x₂-x₁)² + (y₂-y₁)²]
```

這導致：
- 一個很遠但偏離很多的視窗
- 可能比一個較近但方向正確的視窗更容易被選中

## 新演算法：加權距離

### 核心概念
**主方向距離 + 偏移方向距離 × 2**

### 向下/向上
```typescript
// 向下為例
const verticalDistance = win.bounds.y - currentBottom;  // 主方向
const horizontalOffset = Math.abs(currentCenter.x - winCenter.x);  // 偏移
const weightedDistance = verticalDistance + horizontalOffset * 2;  // 水平偏移懲罰更重
```

### 向左/向右
```typescript
// 向右為例
const horizontalDistance = win.bounds.x - currentRight;  // 主方向
const verticalOffset = Math.abs(currentCenter.y - winCenter.y);  // 偏移
const weightedDistance = horizontalDistance + verticalOffset * 2;  // 垂直偏移懲罰更重
```

## 效果對比

### 案例：當前視窗在 (991, 0)，大小 910x689

**候選視窗**：
1. LINE 在 (220, 88)
2. 假設有另一個視窗在 (950, 700)

#### 舊演算法（歐氏距離）
```
LINE:   √[(220-991)² + (88-689)²] = √[594121 + 361201] = 977
視窗2:  √[(950-991)² + (700-689)²] = √[1681 + 121] = 42
```
✅ 選擇視窗2（正確）

但如果視窗2不存在：
```
LINE:   977（唯一候選）
```
❌ 選擇 LINE（錯誤 - 在左邊）

#### 新演算法（加權距離）
```
當前視窗中心: (991 + 910/2, 0 + 689/2) = (1446, 344.5)

LINE:
  垂直距離 = 88 - 689 = -601（負數表示在上方，不符合向下）
  → 被過濾掉

視窗2:
  垂直距離 = 700 - 689 = 11
  水平偏移 = |950 + 寬度/2 - 1446| 
  加權距離 = 11 + 水平偏移 × 2
```
✅ 只選擇真正在下方的視窗

## 新日誌輸出

現在會顯示詳細的判斷過程：

```
[DEBUG] 觸發快速鍵: down
[DEBUG] 當前視窗: LINE (ID:7455) 位置:(991, 0) 大小:910x689
[DEBUG] 獲取到 3 個有效視窗
[DEBUG]   [1] LINE (Unknown) - 位置:(220, 88) 大小:910x689
[DEBUG]   [2] ChatGPT (Unknown) - 位置:(188, 288) 大小:1026x659
[DEBUG]   [3] iTerm2 (Unknown) - 位置:(1512, 25) 大小:1920x1175
[DEBUG] 可切換的視窗數量: 3
[DEBUG] 向下候選視窗: iTerm2 垂直距離:336 水平偏移:611
[INFO] 找到 down 方向的視窗: iTerm2 (ID:xxx) 位置:(1512, 25)
```

**解讀**：
- 雖然 iTerm2 水平偏移 611 很大
- 但它確實在下方（垂直距離 336）
- 而 LINE 和 ChatGPT 都在當前視窗之上，被過濾掉了

## 懲罰權重說明

### 為什麼是 × 2？
```
weightedDistance = mainDistance + offsetDistance × 2
```

**原因**：
- 偏移方向的距離應該比主方向更「昂貴」
- × 2 表示：偏離 100px 相當於主方向的 200px
- 鼓勵選擇「方向正確但較遠」的視窗，而非「方向錯誤但較近」的視窗

### 可調整性
如果覺得太嚴格或太寬鬆，可以調整權重：
- × 1.5：較寬鬆，允許更多偏移
- × 3：較嚴格，優先選擇對齊的視窗

## 測試建議

### 1. 基本方向測試
```
排列：
┌─────┐
│  A  │ ← 當前
└─────┘
┌─────┐
│  B  │ ← 向下應該選這個
└─────┘
```

### 2. 偏移測試
```
排列：
┌─────┐        
│  A  │ ← 當前
└─────┘        
       ┌─────┐
       │  B  │ ← 向下應該選這個（雖然偏右）
       └─────┘
```

### 3. 多候選測試
```
排列：
    ┌─────┐        
    │  A  │ ← 當前
    └─────┘        
┌───┐   ┌───┐
│ B │   │ C │ ← 向下應該選 C（更對齊）
└───┘   └───┘
```

## 已修正的情況

✅ 向下不會選到上方或左方的視窗  
✅ 向上不會選到下方或右方的視窗  
✅ 向左不會選到右方或下方的視窗  
✅ 向右不會選到左方或上方的視窗  
✅ 偏移較大的視窗會被降低優先級  
✅ 方向正確的視窗優先於距離較近的視窗

## 預期改進效果

從你的案例來看：
- 當前：LINE (991, 0)
- 按向下
- 應該選：在 (991, 0) **下方**的視窗
- 不應該選：在左邊的 LINE (220, 88)

現在的演算法會：
1. 過濾出 y > 689 的視窗（當前視窗底部）
2. 計算水平偏移
3. 選擇水平偏移最小的那個

---

**請重新測試，應該能正確切換了！** 🎯
