# Visual Focusing 視窗切換邏輯說明

本文檔詳細說明 Visual Focusing 應用程式的視窗選擇與切換邏輯。

## 目錄

- [概述](#概述)
- [視窗過濾階段](#視窗過濾階段)
- [方向搜尋邏輯](#方向搜尋邏輯)
- [後備搜尋機制](#後備搜尋機制)
- [優先度系統](#優先度系統)
- [評分機制](#評分機制)
- [特殊情況處理](#特殊情況處理)

---

## 概述

Visual Focusing 允許使用者透過快捷鍵（預設為方向鍵）快速切換到目前視窗的上下左右方向視窗。系統會智能選擇最合適的目標視窗。

### 核心設計原則

1. **可見性優先**：只考慮實際有露出的視窗
2. **方向準確性**：嚴格判斷視窗在指定方向
3. **重疊優先**：與當前視窗有重疊的視窗優先度更高
4. **面積加權**：可見面積較大的視窗優先
5. **Z-order 考量**：較上層的視窗有輕微優勢

---

## 視窗過濾階段

在開始搜尋前，系統會先過濾視窗：

### 1. 基本過濾
- **排除當前視窗**：透過 ID 和位置雙重檢查
- **最小尺寸檢查**：排除寬度或高度小於 50px 的視窗
- **最小化視窗**：排除已最小化的視窗

### 2. 可見性過濾（關鍵）

使用 `calculateActualVisibleArea()` 函數計算每個視窗的實際可見比例：

```typescript
// 計算邏輯
1. 找出所有 z-index 比目標視窗小（更上層）的視窗
2. 計算每個上層視窗與目標視窗的重疊比例
3. 取最大重疊比例
4. 可見比例 = 1 - 最大重疊比例（若被完全遮擋則為 0）
```

**過濾規則**：只保留可見比例 > 0 的視窗

> **重要**：此過濾適用於主搜尋和後備搜尋，確保完全被遮擋的視窗永遠不會被選中

---

## 方向搜尋邏輯

每個方向（上/下/左/右）都有專門的搜尋函數。以**向上搜尋**為例：

### 第一階段：方向判定

檢查候選視窗是否在正確方向：

```
向上：target.bounds.y < current.bounds.y
      （目標視窗頂部 < 當前視窗頂部）
      且與當前視窗有水平重疊

向下：target.bounds.y + target.bounds.height > current.bounds.y + current.bounds.height
      （目標視窗底部 > 當前視窗底部）
      且與當前視窗有水平重疊

向左：target.bounds.x < current.bounds.x
      （目標視窗左邊 < 當前視窗左邊）
      且與當前視窗有垂直重疊

向右：target.bounds.x + target.bounds.width > current.bounds.x + current.bounds.width
      （目標視窗右邊 > 當前視窗右邊）
      且與當前視窗有垂直重疊
```

### 第二階段：重疊判定

判斷候選視窗與當前視窗是否有重疊：

```typescript
// 完全重疊 = 水平重疊 && 垂直重疊
hasCompleteOverlap = hasHorizontalOverlap && hasVerticalOverlap

// 水平重疊檢查
hasHorizontalOverlap = !(win1.right <= win2.x || win2.right <= win1.x)

// 垂直重疊檢查  
hasVerticalOverlap = !(win1.bottom <= win2.y || win2.bottom <= win1.y)
```

### 第三階段：全螢幕判定

判斷視窗是否為「包含當前視窗且佔螢幕 90% 以上」：

```typescript
isFullscreenContaining = 
  // 1. 目標視窗完全包含當前視窗
  (target.x <= current.x &&
   target.y <= current.y &&
   target.right >= current.right &&
   target.bottom >= current.bottom) &&
  
  // 2. 目標視窗佔螢幕 90% 以上
  (target.width * target.height >= screenArea * 0.9)
```

### 第四階段：分組與評分

將候選視窗分成三組（優先度由高到低）：

#### **第一組：重疊一般視窗**
- 與當前視窗有重疊（`hasCompleteOverlap = true`）
- 不是全螢幕包含視窗（`isFullscreen = false`）
- **最高優先度**

#### **第二組：不重疊一般視窗**
- 與當前視窗無重疊（`hasCompleteOverlap = false`）
- 不是全螢幕包含視窗（`isFullscreen = false`）
- **中等優先度**

#### **第三組：全螢幕包含視窗**
- 包含當前視窗且佔螢幕 90% 以上（`isFullscreen = true`）
- **最低優先度**（只在前兩組都沒有候選視窗時才考慮）

### 第五階段：最終選擇

```typescript
// 依序選擇
const finalCandidates = 
  overlappingNormalCandidates.length > 0 ? overlappingNormalCandidates :
  nonOverlappingNormalCandidates.length > 0 ? nonOverlappingNormalCandidates :
  fullscreenCandidates;

// 選擇該組中評分最高的
return finalCandidates[0].window;
```

---

## 後備搜尋機制

當主方向搜尋找不到視窗時，啟動後備搜尋。

### 後備搜尋策略

以**向上找不到**為例：

```
主搜尋失敗 → 從當前視窗「上緣」往「下」找重疊視窗
條件：
1. 與當前視窗完全重疊（X、Y 軸都有重疊）
2. Y 座標 > 當前視窗 Y（在下方）
3. 選擇最小的 Y（最接近上緣）
```

### 四個方向的後備邏輯

| 主搜尋方向 | 後備搜尋方向 | 座標條件 | 排序方式 |
|---------|----------|---------|---------|
| 向上找不到 | 從上緣往下 | `Y > current.y` | 升序（選最小 Y） |
| 向下找不到 | 從下緣往上 | `Y < current.bottom` | 降序（選最大 Y） |
| 向左找不到 | 從左緣往右 | `X > current.x` | 升序（選最小 X） |
| 向右找不到 | 從右緣往左 | `X < current.right` | 降序（選最大 X） |

### 後備搜尋的優先度

後備搜尋使用簡化的兩組優先度：

1. **一般視窗優先**：先搜尋非全螢幕包含視窗
2. **全螢幕視窗次之**：找不到才考慮全螢幕包含視窗

```typescript
// 先找一般視窗
const normalCandidates = windows
  .filter(hasCompleteOverlap && !isFullscreen)
  .filter(/* 方向條件 */)
  .sort(/* 按距離 */);

if (normalCandidates.length > 0) return normalCandidates[0];

// 找不到才找全螢幕視窗
const fullscreenCandidates = windows
  .filter(hasCompleteOverlap && isFullscreen)
  .filter(/* 方向條件 */)
  .sort(/* 按距離 */);

if (fullscreenCandidates.length > 0) return fullscreenCandidates[0];

return null;
```

> **注意**：後備搜尋也只考慮實際可見的視窗（傳入的 `windows` 參數已經過可見性過濾）

---

## 優先度系統

### 主搜尋三層優先度

```
┌─────────────────────────────────────┐
│  第一優先：重疊一般視窗              │  ← 最優先選擇
│  • 有重疊 + 不是全螢幕              │
├─────────────────────────────────────┤
│  第二優先：不重疊一般視窗            │  ← 第一組沒有才考慮
│  • 無重疊 + 不是全螢幕              │
├─────────────────────────────────────┤
│  第三優先：全螢幕包含視窗            │  ← 前兩組都沒有才考慮
│  • 包含當前視窗 + 佔螢幕 90% 以上   │
└─────────────────────────────────────┘
```

### 為什麼這樣設計？

1. **重疊視窗通常是使用者關注的焦點**
   - 視窗有重疊表示它們在使用者視野中相近
   - 切換到重疊視窗更符合視覺預期

2. **全螢幕視窗最後考慮**
   - 全螢幕 IDE、瀏覽器等雖然可見但通常是背景工作區
   - 只在沒有其他選擇時才切換到全螢幕視窗
   - 避免頻繁切到大型背景視窗

---

## 評分機制

在每個優先度組別內，使用評分系統選擇最佳視窗。

### 評分公式

```typescript
score = visibleRatio × 500 - distance - zOrderPenalty
```

### 評分組成部分

#### 1. 可見面積分數（visibleRatio × 500）

```typescript
// visibleRatio 範圍：0.0 ~ 1.0
// 最大貢獻：500 分
visibleScore = visibleRatio × 500

例如：
- 100% 可見 → 500 分
- 50% 可見 → 250 分
- 10% 可見 → 50 分
```

**設計理由**：
- 優先選擇可見面積較大的視窗
- 係數 500 確保可見度是主要因素
- 即使距離較遠，高可見度視窗仍可能被選中

#### 2. 距離懲罰（-distance）

距離計算方式依方向而異：

**向上/向下（垂直方向）**：

```typescript
// 計算當前視窗邊緣到目標視窗邊緣的距離
// 向上：當前頂部到目標底部；向下：目標頂部到當前底部
// 有重疊時距離為 0
const verticalDistance = Math.max(0, currentTop - winBottom); // 以向上為例

distance = verticalDistance;
```

**向左/向右（水平方向）**：

```typescript
// 計算當前視窗邊緣到目標視窗邊緣的距離
// 向左：當前左邊到目標右邊；向右：目標左邊到當前右邊
// 有重疊時距離為 0
const horizontalDistance = Math.max(0, currentLeft - winRight); // 以向左為例

distance = horizontalDistance;
```

**注意**：距離計算使用邊到邊距離（非中心到中心），且只計算主方向的距離分量。

#### 3. Z-order 懲罰（-zOrderPenalty）

```typescript
// z-index 越小 = 越上層
// 懲罰 = z-index × 50
zOrderPenalty = zIndex × 50

例如：
- Z-index 0（最上層）→ 0 分懲罰
- Z-index 1 → 50 分懲罰
- Z-index 5 → 250 分懲罰
```

**設計理由**：
- 優待較上層的視窗
- 係數 50 確保 Z-order 有一定影響力
- 但可見面積（最大 500）仍是主要因素

### 評分範例

假設向上搜尋，有三個候選視窗：

| 視窗 | 可見度 | 距離 | Z-index | 計算過程 | 總分 |
|------|--------|------|---------|---------|------|
| A | 80% | 100px | 2 | 400 - 100 - 100 | **200** ✓ 最高分 |
| B | 100% | 350px | 0 | 500 - 350 - 0 | **150** |
| C | 50% | 50px | 1 | 250 - 50 - 50 | **150** |

視窗 A 被選中，因為綜合評分最高。

---

## 特殊情況處理

### 1. 完全被遮擋的視窗

**處理方式**：在搜尋前就被過濾掉

```typescript
// 可見性過濾（calculateActualVisibleArea）
if (visibleRatio === 0) {
  // 完全被遮擋，不列入任何搜尋
  logger.debug(`[過濾] ${win.title} - 完全被遮擋`);
  continue;
}
```

### 2. 全螢幕包含視窗

**場景**：大型 IDE、全螢幕瀏覽器等

**判定條件**：
- 完全包含當前視窗
- 佔螢幕面積 ≥ 90%

**處理方式**：
- 不排除，但設為最低優先度
- 只在沒有一般視窗時才被選中

**設計理由**：
```
使用者場景：
1. 在全螢幕 VSCode 中有一個小視窗（如 Terminal）
2. 向上切換時，不希望切回 VSCode（因為已經在裡面）
3. 應該切換到其他小視窗（如瀏覽器、Slack）
4. 但如果沒有其他選擇，仍可切回 VSCode
```

### 3. 最小化視窗

**處理方式**：在基本過濾階段就被排除

```typescript
if (isMinimized(win)) {
  return false;  // 不列入搜尋
}
```

### 4. 極小視窗

**處理方式**：寬度或高度 < 50px 的視窗被排除

```typescript
if (win.width < MIN_WINDOW_SIZE || win.height < MIN_WINDOW_SIZE) {
  return false;
}
```

### 5. 沒有任何可切換視窗

**處理流程**：

```
1. 主搜尋找不到
   ↓
2. 後備搜尋找不到
   ↓
3. 返回 null
   ↓
4. 不執行切換動作（保持在當前視窗）
```

### 6. 多顯示器環境

**目前實作**：
- 取得主顯示器尺寸作為螢幕參考
- 全螢幕判定使用主顯示器面積

**限制**：
- 跨顯示器切換可能不如預期
- 未來可考慮支援多顯示器感知

---

## 除錯日誌說明

系統提供詳細的除錯日誌，方便追蹤選擇邏輯。

### 日誌階段

#### 1. 可見性過濾階段

```
可切換的視窗數量: 5
  [過濾] Window1 - 完全被遮擋 (可見度: 0.0%)
  [過濾] Window2 - 完全被遮擋 (可見度: 0.0%)
實際可見的視窗數量: 3
```

#### 2. 方向搜尋階段

```
=== 尋找上方視窗 ===
[DEBUG] 當前視窗: ChatGPT
[DEBUG]   位置: (788, 123) 大小: 714x659
[DEBUG]   頂部 Y = 123
[DEBUG]   X 範圍: 788 ~ 1502

檢查: iTerm2 [Z:1]
  位置: (1699, 95) 大小: 1649x1036
  條件1 [頂部Y]: 95 < 123 ? ✓ 是
  條件2 [X重疊]: 當前[788~1502] vs 目標[1699~3348] ? ✗ 無重疊
  → 結果: ✗✗ 不符合

檢查: LINE [Z:2]
  位置: (483, 232) 大小: 584x750
  條件1 [頂部Y]: 232 < 123 ? ✗ 否
  → 結果: ✗✗ 不符合
```

#### 3. 分組與評分階段

```
符合條件的候選視窗: 2 個

【重疊組】候選視窗: 1 個
  1. Window1 [Z:1] [重疊✓]
     加權分數:350 = 可見×500(400) - 垂直距離(0) - Z懲罰(50)
     可見面積比例: 80.0%

【不重疊組】候選視窗: 1 個
  1. Window2 [Z:3]
     加權分數:50 = 可見×500(200) - 垂直距離(0) - Z懲罰(150)
     可見面積比例: 40.0%

→ 最終選擇: Window1
```

#### 4. 後備搜尋階段

```
上方沒有找到視窗，啟動後備搜尋...

=== 後備搜尋：從上緣往下找重疊視窗 ===
當前視窗: ChatGPT
  Y 座標: 123
  搜尋條件: 與當前視窗完全重疊 且 Y > 123（在下方）

找到 1 個一般視窗候選
選擇最接近的: LINE (Y: 232)
```

---

## 總結

Visual Focusing 的視窗切換邏輯經過精心設計，確保：

1. ✅ **只選擇實際可見的視窗**（過濾完全被遮擋）
2. ✅ **重疊視窗優先**（符合視覺預期）
3. ✅ **可見面積加權**（優先選擇露出較多的視窗）
4. ✅ **全螢幕視窗最後考慮**（避免頻繁切到背景工作區）
5. ✅ **後備搜尋機制**（找不到時從其他方向尋找重疊視窗）
6. ✅ **距離與 Z-order 微調**（在相似候選中選擇最佳）

這套邏輯平衡了使用者的直覺預期與實際使用場景，提供流暢的視窗切換體驗。

---

**文檔版本**：v1.1  
**最後更新**：2026-02-27  
**對應程式版本**：Phase 12 完成後
